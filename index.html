<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neo-Baghdad: The Eternal Round City</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        :root { --neon: #00f2ff; --gold: #ffd700; --magenta: #ff007b; --bg: #020205; }
        
        /* FIX: Prevents the 'infinite scroll' by locking the body */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: var(--bg); font-family: 'Orbitron', sans-serif; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }

        /* Cinematic Intro Sequence */
        #boot-seq { 
            position: fixed; inset: 0; background: var(--bg); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 1000; transition: 2s cubic-bezier(0.8, 0, 0.2, 1); 
        }
        .glitch-title { 
            font-size: 5rem; letter-spacing: 25px; color: var(--neon); 
            text-shadow: 0 0 30px var(--neon); animation: glitch 3s infinite;
        }
        .launch-btn { 
            margin-top: 50px; padding: 20px 60px; background: transparent; 
            border: 2px solid var(--gold); color: var(--gold); cursor: pointer; 
            font-family: 'Cinzel'; letter-spacing: 10px; font-size: 1.2rem; transition: 0.5s;
        }
        .launch-btn:hover { background: var(--gold); color: black; box-shadow: 0 0 50px var(--gold); transform: scale(1.05); }

        /* Interactive UI Layers */
        #hud { position: fixed; inset: 0; pointer-events: none; z-index: 10; border: 1px solid rgba(0, 242, 255, 0.1); }
        #building-card { 
            position: fixed; bottom: 40px; right: 40px; width: 380px; 
            background: rgba(5, 5, 20, 0.95); border-right: 4px solid var(--neon); 
            padding: 30px; display: none; backdrop-filter: blur(25px); z-index: 100;
            box-shadow: -20px 20px 60px rgba(0,0,0,0.8);
        }
        #building-card h2 { color: var(--neon); margin: 0 0 15px 0; border-bottom: 1px solid rgba(0,242,255,0.2); padding-bottom: 10px; }

        @keyframes glitch {
            0% { transform: skew(0deg); }
            2% { transform: skew(10deg); filter: hue-rotate(90deg); }
            4% { transform: skew(-10deg); }
            6% { transform: skew(0deg); }
        }
    </style>
</head>
<body>
    <div id="boot-seq">
        <h1 class="glitch-title">NEO-BAGHDAD</h1>
        <p style="color: #555; letter-spacing: 12px;">QUANTUM ARCHITECTURAL UPLINK V7.0</p>
        <button class="launch-btn" onclick="initSimulation()">INITIATE NEURAL LINK</button>
    </div>

    <div id="hud"></div>
    <div id="building-card"><h2 id="card-t"></h2><p id="card-d"></p></div>

    <script type="importmap"> { "imports": { "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js" } } </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls, cityMesh, trafficNodes = [];
        const mosqueObjects = [];
        const mouse = new THREE.Vector2(), raycaster = new THREE.Raycaster();

        window.initSimulation = () => {
            document.getElementById('boot-seq').style.opacity = '0';
            document.getElementById('boot-seq').style.transform = 'scale(1.5)';
            setTimeout(() => { 
                document.getElementById('boot-seq').remove(); 
                startEngine(); 
            }, 1200);
        };

        function startEngine() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x010105);
            scene.fog = new THREE.FogExp2(0x010105, 0.0001);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(5000, 3500, 5000);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.8; // High visibility
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2.1;

            // VISIBILITY UPGRADE: Advanced Lighting
            const sun = new THREE.DirectionalLight(0xffffff, 2.5);
            sun.position.set(2000, 4000, 2000);
            const ambient = new THREE.AmbientLight(0x4040ff, 0.7); // Deep blue fill
            const bluePoint = new THREE.PointLight(0x00f2ff, 4, 10000);
            bluePoint.position.set(0, 1000, 0);
            scene.add(sun, ambient, bluePoint);

            generateWorld();
            spawnTraffic();
            window.addEventListener('click', handleRaycast);
            animate();
        }

        function generateWorld() {
            // High-Contrast Grid Floor
            const grid = new THREE.GridHelper(20000, 80, 0x00f2ff, 0x050515);
            scene.add(grid);

            // The Triple Wall System (From your Reference Image)
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 0.9, roughness: 0.2 });
            const neonRing = (r, h, col) => {
                const wall = new THREE.Mesh(new THREE.TorusGeometry(r, 40, 16, 128), wallMat);
                wall.rotation.x = Math.PI/2;
                const ring = new THREE.Mesh(new THREE.TorusGeometry(r+10, 5, 8, 128), new THREE.MeshBasicMaterial({color: col}));
                ring.rotation.x = Math.PI/2; ring.position.y = h;
                scene.add(wall, ring);
            };
            neonRing(3000, 40, 0x00f2ff); // Outer Wall
            neonRing(1200, 100, 0xff00ff); // Inner Palace Wall

            // PLACES OF WORSHIP: Distinctive Domes (Fixes visibility of religious sites)
            const worshipSites = ["Grand Sapphire Mosque", "Dome of Knowledge", "Al-Khulafa Nexus"];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const dist = 1400 + Math.random() * 200;
                
                const site = new THREE.Group();
                const dome = new THREE.Mesh(new THREE.SphereGeometry(80, 32, 32), new THREE.MeshStandardMaterial({
                    color: 0x00f2ff, emissive: 0x00f2ff, emissiveIntensity: 5, metalness: 1
                }));
                dome.position.y = 120;
                const base = new THREE.Mesh(new THREE.CylinderGeometry(100, 110, 200, 8), wallMat);
                site.add(dome, base);
                site.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
                site.userData = { t: worshipSites[i%3], d: "Ancient architectural geometry fused with modern neural-glass tech." };
                scene.add(site);
                mosqueObjects.push(site);
            }

            // ADVANCED BUILDING ALGORITHM: Glass & Emissive Windows
            const buildCount = 10000;
            const bGeo = new THREE.BoxGeometry(1, 1, 1);
            const bMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x111111, metalness: 0.9, roughness: 0.1, transmission: 0.3, thickness: 2
            });
            cityMesh = new THREE.InstancedMesh(bGeo, bMat, buildCount);
            
            const dummy = new THREE.Object3D();
            let actualIdx = 0;

            for (let i = 0; i < buildCount; i++) {
                const r = 1600 + Math.random() * 1400;
                const a = Math.random() * Math.PI * 2;
                
                // Historical Gate Road Clearing (North, South, East, West)
                if (Math.abs(a % (Math.PI / 2)) < 0.12) continue;

                const h = 100 + Math.pow(Math.random(), 5) * 1800; // Skyscrapers
                dummy.position.set(Math.cos(a)*r, h/2, Math.sin(a)*r);
                dummy.scale.set(40 + Math.random()*20, h, 40 + Math.random()*20);
                dummy.rotation.y = -a;
                dummy.updateMatrix();
                
                cityMesh.setMatrixAt(actualIdx, dummy.matrix);
                // Visible Blue-tinted window shades
                cityMesh.setColorAt(actualIdx++, new THREE.Color().setHSL(0.55, 1, 0.2 + Math.random()*0.3));
            }
            scene.add(cityMesh);
        }

        function spawnTraffic() {
            const carGeo = new THREE.BoxGeometry(20, 3, 8);
            const carMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = 0; i < 500; i++) {
                const car = new THREE.Mesh(carGeo, carMat);
                car.userData = { axis: Math.floor(Math.random()*4), spd: 15 + Math.random()*30, p: Math.random()*8000-4000 };
                trafficNodes.push(car);
                scene.add(car);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            trafficNodes.forEach(c => {
                c.userData.p += c.userData.spd;
                if (c.userData.p > 4000) c.userData.p = -4000;
                const off = (c.userData.axis % 2 === 0) ? 80 : -80;
                if (c.userData.axis < 2) c.position.set(c.userData.p, 500 + (c.userData.axis * 150), off);
                else c.position.set(off, 600 + (c.userData.axis * 80), c.userData.p);
            });
            controls.update();
            renderer.render(scene, camera);
        }

        function handleRaycast(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const mHits = raycaster.intersectObjects(mosqueObjects, true);
            if (mHits.length > 0) {
                const d = mHits[0].object.parent.userData;
                return updateCard(d.t, d.d);
            }

            const cHits = raycaster.intersectObject(cityMesh);
            if (cHits.length > 0) {
                updateCard("Sovereign Spire " + (cHits[0].instanceId % 999), "High-density neural housing unit.");
            }
        }

        function updateCard(t, d) {
            document.getElementById('card-t').innerText = t;
            document.getElementById('card-d').innerText = d;
            document.getElementById('building-card').style.display = 'block';
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
